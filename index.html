<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>MartinCraft</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; touch-action: none; }
canvas { display: block; }

#menu {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: linear-gradient(180deg, #87CEEB 0%, #4a90d9 50%, #2d5a1e 50%, #1a3a0e 100%);
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  z-index: 1000;
}
#menu h1 {
  font-size: 48px; color: #fff; text-shadow: 3px 3px 0 #333, -1px -1px 0 #555;
  font-family: 'Courier New', monospace; letter-spacing: 4px; margin-bottom: 40px;
}
#menu button {
  font-size: 24px; padding: 15px 50px; margin: 10px;
  background: #8B8B8B; border: 3px solid #555; color: #fff;
  font-family: 'Courier New', monospace; cursor: pointer;
  text-shadow: 1px 1px 0 #333;
}
#menu button:hover, #menu button:active { background: #6d6d6d; }

#hud {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; z-index: 100; display: none;
}
#crosshair {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  width: 24px; height: 24px;
}
#crosshair-v, #crosshair-h { position: absolute; background: #fff; }
#crosshair-v { width: 2px; height: 24px; left: 11px; top: 0; }
#crosshair-h { width: 24px; height: 2px; top: 11px; left: 0; }

#hearts {
  position: absolute; top: 10px; left: 10px;
  display: flex; gap: 3px;
}
.heart {
  width: 28px; height: 28px; font-size: 22px; line-height: 28px; text-align: center;
}

#hotbar {
  position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%);
  display: flex; background: rgba(0,0,0,0.6); border: 2px solid #555;
  pointer-events: auto;
}
.hotbar-slot {
  width: 50px; height: 50px; border: 1px solid #444;
  display: flex; align-items: center; justify-content: center;
  position: relative;
}
.hotbar-slot.selected { border: 2px solid #fff; background: rgba(255,255,255,0.2); }
.hotbar-slot canvas { width: 36px; height: 36px; image-rendering: pixelated; }
.hotbar-count {
  position: absolute; bottom: 2px; right: 4px; color: #fff; font-size: 12px;
  text-shadow: 1px 1px 0 #000;
}

#touch-controls {
  position: fixed; bottom: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; z-index: 99; display: none;
}
#joystick-area {
  position: absolute; bottom: 20px; left: 20px;
  width: 140px; height: 140px; pointer-events: auto;
}
#joystick-base {
  width: 120px; height: 120px; border-radius: 50%;
  background: rgba(255,255,255,0.15); border: 2px solid rgba(255,255,255,0.3);
  position: absolute; bottom: 10px; left: 10px;
}
#joystick-thumb {
  width: 50px; height: 50px; border-radius: 50%;
  background: rgba(255,255,255,0.4);
  position: absolute; top: 35px; left: 35px;
}

#action-buttons {
  position: absolute; bottom: 20px; right: 20px;
  display: flex; flex-direction: column; gap: 10px;
  pointer-events: auto;
}
.action-btn {
  width: 60px; height: 60px; border-radius: 50%;
  background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.4);
  color: #fff; font-size: 12px; font-weight: bold;
  display: flex; align-items: center; justify-content: center;
  text-shadow: 1px 1px 0 #000; font-family: 'Courier New', monospace;
}
#jump-btn {
  position: absolute; bottom: 90px; right: 100px;
  width: 60px; height: 60px; border-radius: 50%;
  background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.4);
  color: #fff; font-size: 20px; font-weight: bold;
  display: flex; align-items: center; justify-content: center;
  pointer-events: auto;
}

#debug-info {
  position: absolute; top: 10px; right: 110px;
  color: #fff; font-size: 12px; text-shadow: 1px 1px 0 #000;
  white-space: pre-line;
}

#death-screen {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(200, 0, 0, 0.6);
  display: none; flex-direction: column; align-items: center; justify-content: center;
  z-index: 200;
}
#death-screen h2 { color: #fff; font-size: 36px; margin-bottom: 20px; }
#death-screen button {
  font-size: 20px; padding: 12px 40px;
  background: #8B8B8B; border: 3px solid #555; color: #fff;
  font-family: 'Courier New', monospace; cursor: pointer;
}

#pause-btn {
  position: absolute; top: 10px; right: 10px;
  width: 40px; height: 40px;
  background: rgba(0,0,0,0.4); border: 1px solid #666;
  color: #fff; font-size: 20px; pointer-events: auto;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer;
}

#loading {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: #2d1a0e; display: none; flex-direction: column;
  align-items: center; justify-content: center; z-index: 1001;
  color: #fff; font-size: 24px;
}
#loading-bar {
  width: 300px; height: 20px; background: #555; margin-top: 20px; border: 2px solid #888;
}
#loading-fill { width: 0%; height: 100%; background: #4CAF50; transition: width 0.3s; }
</style>
</head>
<body>

<div id="menu">
  <h1>MartinCraft</h1>
  <button id="play-btn">Novo Jogo</button>
  <button id="continue-btn" style="display:none">Continuar</button>
</div>

<div id="loading">
  <div>A criar o mundo...</div>
  <div id="loading-bar"><div id="loading-fill"></div></div>
</div>

<div id="death-screen">
  <h2>Morreste!</h2>
  <button id="respawn-btn">Renascer</button>
</div>

<div id="hud">
  <div id="crosshair"><div id="crosshair-v"></div><div id="crosshair-h"></div></div>
  <div id="hearts"></div>
  <div id="hotbar"></div>
  <div id="debug-info"></div>
  <div id="save-btn" style="position:absolute;top:10px;right:60px;width:40px;height:40px;background:rgba(0,0,0,0.4);border:1px solid #666;color:#fff;font-size:14px;pointer-events:auto;display:flex;align-items:center;justify-content:center;cursor:pointer">S</div>
  <div id="save-msg" style="position:absolute;top:55px;right:10px;color:#4f4;font-size:14px;text-shadow:1px 1px 0 #000;opacity:0;transition:opacity 0.5s"></div>
  <div id="pause-btn">||</div>
</div>

<div id="touch-controls">
  <div id="joystick-area">
    <div id="joystick-base">
      <div id="joystick-thumb"></div>
    </div>
  </div>
  <div id="jump-btn">^</div>
  <div id="action-buttons">
    <div class="action-btn" id="break-btn">X</div>
    <div class="action-btn" id="place-btn">+</div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
// ============================================================
// MARTINCRAFT
// ============================================================

var CHUNK_SIZE = 16;
var CHUNK_HEIGHT = 64;
var RENDER_DIST = 4;
var SEA_LEVEL = 20;
var GRAVITY = -25;
var JUMP_FORCE = 9;
var PLAYER_SPEED = 5.5;
var PLAYER_HEIGHT = 1.7;
var PLAYER_WIDTH = 0.6;
var DAY_LENGTH = 600;
var BLOCK_BREAK_TIME = 0.4;
var ZOMBIE_SPEED = 2.5;
var ZOMBIE_DAMAGE = 1;
var ZOMBIE_RANGE = 1.5;
var ZOMBIE_SPAWN_DIST_MIN = 15;
var ZOMBIE_SPAWN_DIST_MAX = 35;
var MAX_ZOMBIES = 8;

var B = {
  AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, WOOD: 4, LEAVES: 5,
  SAND: 6, WATER: 7, COAL: 8, IRON: 9, GOLD: 10, DIAMOND: 11,
  PLANKS: 12, COBBLE: 13, BEDROCK: 14, GLASS: 15
};

var BLOCK_HARDNESS = {};
BLOCK_HARDNESS[B.GRASS] = 1;
BLOCK_HARDNESS[B.DIRT] = 0.8;
BLOCK_HARDNESS[B.STONE] = 2;
BLOCK_HARDNESS[B.WOOD] = 1.5;
BLOCK_HARDNESS[B.LEAVES] = 0.3;
BLOCK_HARDNESS[B.SAND] = 0.8;
BLOCK_HARDNESS[B.COAL] = 2.2;
BLOCK_HARDNESS[B.IRON] = 2.5;
BLOCK_HARDNESS[B.GOLD] = 2.5;
BLOCK_HARDNESS[B.DIAMOND] = 3;
BLOCK_HARDNESS[B.PLANKS] = 1.2;
BLOCK_HARDNESS[B.COBBLE] = 2;
BLOCK_HARDNESS[B.BEDROCK] = Infinity;
BLOCK_HARDNESS[B.GLASS] = 0.5;

var TRANSPARENT_BLOCKS = [B.AIR, B.WATER, B.GLASS, B.LEAVES];
function isTransparent(b) { return TRANSPARENT_BLOCKS.indexOf(b) >= 0; }

// ============================================================
// SIMPLEX NOISE
// ============================================================
function SimplexNoise(seed) {
  this.p = new Uint8Array(512);
  var perm = new Uint8Array(256);
  for (var i = 0; i < 256; i++) perm[i] = i;
  seed = seed || Math.random() * 65536;
  for (var i = 255; i > 0; i--) {
    seed = (seed * 16807 + 0) % 2147483647;
    var j = seed % (i + 1);
    var tmp = perm[i]; perm[i] = perm[j]; perm[j] = tmp;
  }
  for (var i = 0; i < 512; i++) this.p[i] = perm[i & 255];
}

SimplexNoise.prototype.noise2D = function(x, y) {
  var F2 = 0.5 * (Math.sqrt(3) - 1);
  var G2 = (3 - Math.sqrt(3)) / 6;
  var s = (x + y) * F2;
  var i = Math.floor(x + s), j = Math.floor(y + s);
  var t = (i + j) * G2;
  var x0 = x - (i - t), y0 = y - (j - t);
  var i1 = x0 > y0 ? 1 : 0, j1 = x0 > y0 ? 0 : 1;
  var x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
  var x2 = x0 - 1 + 2 * G2, y2 = y0 - 1 + 2 * G2;
  var ii = i & 255, jj = j & 255;
  var p = this.p;
  function g(h, x, y) {
    var v = h & 3;
    return (v === 0 ? x + y : v === 1 ? -x + y : v === 2 ? x - y : -x - y);
  }
  var n0 = 0, n1 = 0, n2 = 0;
  var t0 = 0.5 - x0 * x0 - y0 * y0;
  if (t0 > 0) { t0 *= t0; n0 = t0 * t0 * g(p[ii + p[jj]], x0, y0); }
  var t1 = 0.5 - x1 * x1 - y1 * y1;
  if (t1 > 0) { t1 *= t1; n1 = t1 * t1 * g(p[ii + i1 + p[jj + j1]], x1, y1); }
  var t2 = 0.5 - x2 * x2 - y2 * y2;
  if (t2 > 0) { t2 *= t2; n2 = t2 * t2 * g(p[ii + 1 + p[jj + 1]], x2, y2); }
  return 70 * (n0 + n1 + n2);
};

SimplexNoise.prototype.noise3D = function(x, y, z) {
  var F3 = 1/3, G3 = 1/6;
  var s = (x + y + z) * F3;
  var i = Math.floor(x + s), j = Math.floor(y + s), k = Math.floor(z + s);
  var t = (i + j + k) * G3;
  var x0 = x-(i-t), y0 = y-(j-t), z0 = z-(k-t);
  var i1,j1,k1,i2,j2,k2;
  if (x0>=y0) {
    if (y0>=z0){i1=1;j1=0;k1=0;i2=1;j2=1;k2=0;}
    else if(x0>=z0){i1=1;j1=0;k1=0;i2=1;j2=0;k2=1;}
    else{i1=0;j1=0;k1=1;i2=1;j2=0;k2=1;}
  } else {
    if(y0<z0){i1=0;j1=0;k1=1;i2=0;j2=1;k2=1;}
    else if(x0<z0){i1=0;j1=1;k1=0;i2=0;j2=1;k2=1;}
    else{i1=0;j1=1;k1=0;i2=1;j2=1;k2=0;}
  }
  var x1=x0-i1+G3,y1=y0-j1+G3,z1=z0-k1+G3;
  var x2=x0-i2+2*G3,y2=y0-j2+2*G3,z2=z0-k2+2*G3;
  var x3=x0-1+3*G3,y3=y0-1+3*G3,z3=z0-1+3*G3;
  var ii=i&255,jj=j&255,kk=k&255;
  var p = this.p;
  function g(h,x,y,z) {
    var v=h%12;
    return (v<4?x:v<8?y:z)*(v%2===0?1:-1)+(v<4?y:v<8?z:x)*(v%4<2?1:-1);
  }
  var n0=0,n1=0,n2=0,n3=0;
  var t0=0.6-x0*x0-y0*y0-z0*z0;
  if(t0>0){t0*=t0;n0=t0*t0*g(p[ii+p[jj+p[kk]]],x0,y0,z0);}
  var t1=0.6-x1*x1-y1*y1-z1*z1;
  if(t1>0){t1*=t1;n1=t1*t1*g(p[ii+i1+p[jj+j1+p[kk+k1]]],x1,y1,z1);}
  var t2=0.6-x2*x2-y2*y2-z2*z2;
  if(t2>0){t2*=t2;n2=t2*t2*g(p[ii+i2+p[jj+j2+p[kk+k2]]],x2,y2,z2);}
  var t3=0.6-x3*x3-y3*y3-z3*z3;
  if(t3>0){t3*=t3;n3=t3*t3*g(p[ii+1+p[jj+1+p[kk+1]]],x3,y3,z3);}
  return 32*(n0+n1+n2+n3);
};

SimplexNoise.prototype.octave2D = function(x, y, octaves, persistence) {
  var total = 0, frequency = 1, amplitude = 1, maxVal = 0;
  for (var i = 0; i < octaves; i++) {
    total += this.noise2D(x * frequency, y * frequency) * amplitude;
    maxVal += amplitude;
    amplitude *= persistence;
    frequency *= 2;
  }
  return total / maxVal;
};

// ============================================================
// TEXTURAS PROCEDURAIS
// ============================================================
var TEX_SIZE = 16;
var ATLAS_COLS = 16;
var ATLAS_ROWS = 4;

function createTextureAtlas() {
  var canvas = document.createElement('canvas');
  canvas.width = TEX_SIZE * ATLAS_COLS;
  canvas.height = TEX_SIZE * ATLAS_ROWS;
  var ctx = canvas.getContext('2d');

  function drawAt(col, row, drawFn) {
    ctx.save();
    ctx.translate(col * TEX_SIZE, row * TEX_SIZE);
    drawFn(ctx);
    ctx.restore();
  }

  function fillBase(c, color) {
    c.fillStyle = color;
    c.fillRect(0, 0, TEX_SIZE, TEX_SIZE);
  }

  function noise(c, color, count) {
    c.fillStyle = color;
    for (var i = 0; i < count; i++) {
      c.fillRect(Math.floor(Math.random()*TEX_SIZE), Math.floor(Math.random()*TEX_SIZE), 1, 1);
    }
  }

  function oreSpots(c, color, count) {
    c.fillStyle = color;
    for (var i = 0; i < count; i++) {
      var cx2 = 3+Math.floor(Math.random()*10), cy2 = 3+Math.floor(Math.random()*10);
      c.fillRect(cx2, cy2, 2, 2);
      c.fillRect(cx2+1, cy2+1, 2, 1);
    }
  }

  // Grass top
  drawAt(0, 0, function(c) { fillBase(c,'#4a8c2a'); noise(c,'#3d7a22',25); noise(c,'#5a9e35',15); });
  // Grass side
  drawAt(1, 0, function(c) {
    fillBase(c,'#8B6914'); noise(c,'#7a5c10',20);
    c.fillStyle='#4a8c2a'; c.fillRect(0,0,TEX_SIZE,3);
    c.fillStyle='#3d7a22';
    for(var x=0;x<TEX_SIZE;x++) if(Math.random()>0.5) c.fillRect(x,3,1,1);
  });
  // Dirt
  drawAt(2, 0, function(c) { fillBase(c,'#8B6914'); noise(c,'#7a5c10',25); noise(c,'#9a7620',10); });
  // Stone
  drawAt(3, 0, function(c) { fillBase(c,'#888'); noise(c,'#777',30); noise(c,'#999',20); noise(c,'#666',10); });
  // Wood top
  drawAt(4, 0, function(c) {
    fillBase(c,'#B08040');
    c.strokeStyle='#906830'; c.lineWidth=1;
    c.beginPath(); c.arc(8,8,5,0,Math.PI*2); c.stroke();
    c.beginPath(); c.arc(8,8,3,0,Math.PI*2); c.stroke();
    c.fillStyle='#704020'; c.fillRect(7,7,2,2);
  });
  // Wood side
  drawAt(5, 0, function(c) {
    fillBase(c,'#6B4226');
    for(var x=0;x<TEX_SIZE;x+=3) {
      c.fillStyle=Math.random()>0.5?'#5a3620':'#7a4e30';
      c.fillRect(x,0,2,TEX_SIZE);
    }
    noise(c,'#5a3620',10);
  });
  // Leaves
  drawAt(6, 0, function(c) { fillBase(c,'#2d6e12'); noise(c,'#1d5e08',30); noise(c,'#3d8e22',20); noise(c,'#4a9e2a',10); });
  // Sand
  drawAt(7, 0, function(c) { fillBase(c,'#e8d5a0'); noise(c,'#d4c090',20); noise(c,'#f0e0b0',15); });
  // Water
  drawAt(8, 0, function(c) {
    fillBase(c,'#3366aa'); noise(c,'#2855a0',15);
    c.fillStyle='rgba(100,180,255,0.3)'; c.fillRect(2,5,6,1); c.fillRect(8,10,5,1);
  });
  // Coal ore
  drawAt(9, 0, function(c) { fillBase(c,'#888'); noise(c,'#777',20); oreSpots(c,'#222',4); });
  // Iron ore
  drawAt(10, 0, function(c) { fillBase(c,'#888'); noise(c,'#777',20); oreSpots(c,'#c4a882',4); });
  // Gold ore
  drawAt(11, 0, function(c) { fillBase(c,'#888'); noise(c,'#777',20); oreSpots(c,'#ffe040',3); });
  // Diamond ore
  drawAt(12, 0, function(c) { fillBase(c,'#888'); noise(c,'#777',20); oreSpots(c,'#40e0e0',3); });
  // Planks
  drawAt(13, 0, function(c) {
    fillBase(c,'#B89050');
    for(var y=0;y<TEX_SIZE;y+=4){c.fillStyle='#a07840';c.fillRect(0,y,TEX_SIZE,1);}
    noise(c,'#a08040',10);
  });
  // Cobblestone
  drawAt(14, 0, function(c) {
    fillBase(c,'#777');
    for(var i=0;i<8;i++){
      c.fillStyle=Math.random()>0.5?'#666':'#888';
      c.fillRect(Math.floor(Math.random()*12),Math.floor(Math.random()*12),
        3+Math.floor(Math.random()*3),2+Math.floor(Math.random()*3));
    }
    noise(c,'#555',10);
  });
  // Bedrock
  drawAt(15, 0, function(c) { fillBase(c,'#333'); noise(c,'#222',30); noise(c,'#444',20); });
  // Glass
  drawAt(0, 1, function(c) {
    fillBase(c,'rgba(200,220,255,0.3)');
    c.strokeStyle='rgba(255,255,255,0.5)'; c.lineWidth=1;
    c.strokeRect(0,0,TEX_SIZE,TEX_SIZE);
    c.strokeRect(1,1,TEX_SIZE-2,TEX_SIZE-2);
  });

  return canvas;
}

var BLOCK_UVS = {};
BLOCK_UVS[B.GRASS]   = { top:[0,0], side:[1,0], bottom:[2,0] };
BLOCK_UVS[B.DIRT]    = { top:[2,0], side:[2,0], bottom:[2,0] };
BLOCK_UVS[B.STONE]   = { top:[3,0], side:[3,0], bottom:[3,0] };
BLOCK_UVS[B.WOOD]    = { top:[4,0], side:[5,0], bottom:[4,0] };
BLOCK_UVS[B.LEAVES]  = { top:[6,0], side:[6,0], bottom:[6,0] };
BLOCK_UVS[B.SAND]    = { top:[7,0], side:[7,0], bottom:[7,0] };
BLOCK_UVS[B.WATER]   = { top:[8,0], side:[8,0], bottom:[8,0] };
BLOCK_UVS[B.COAL]    = { top:[9,0], side:[9,0], bottom:[9,0] };
BLOCK_UVS[B.IRON]    = { top:[10,0], side:[10,0], bottom:[10,0] };
BLOCK_UVS[B.GOLD]    = { top:[11,0], side:[11,0], bottom:[11,0] };
BLOCK_UVS[B.DIAMOND] = { top:[12,0], side:[12,0], bottom:[12,0] };
BLOCK_UVS[B.PLANKS]  = { top:[13,0], side:[13,0], bottom:[13,0] };
BLOCK_UVS[B.COBBLE]  = { top:[14,0], side:[14,0], bottom:[14,0] };
BLOCK_UVS[B.BEDROCK] = { top:[15,0], side:[15,0], bottom:[15,0] };
BLOCK_UVS[B.GLASS]   = { top:[0,1], side:[0,1], bottom:[0,1] };

// ============================================================
// MUNDO
// ============================================================
function World(seed) {
  this.seed = seed;
  this.noise = new SimplexNoise(seed);
  this.chunks = {};
  this.meshes = {};
  this.modifications = {};
}

World.prototype.chunkKey = function(cx, cz) { return cx + ',' + cz; };

World.prototype.getChunk = function(cx, cz) {
  var key = this.chunkKey(cx, cz);
  if (!this.chunks[key]) {
    this.chunks[key] = this.generateChunk(cx, cz);
  }
  return this.chunks[key];
};

World.prototype.getBlock = function(x, y, z) {
  if (y < 0 || y >= CHUNK_HEIGHT) return B.AIR;
  var cx = Math.floor(x / CHUNK_SIZE);
  var cz = Math.floor(z / CHUNK_SIZE);
  var lx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
  var lz = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
  var chunk = this.getChunk(cx, cz);
  return chunk[lx + lz * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE];
};

World.prototype.setBlock = function(x, y, z, type) {
  if (y < 0 || y >= CHUNK_HEIGHT) return;
  var cx = Math.floor(x / CHUNK_SIZE);
  var cz = Math.floor(z / CHUNK_SIZE);
  var lx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
  var lz = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
  var chunk = this.getChunk(cx, cz);
  chunk[lx + lz * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE] = type;
  this.modifications[x+','+y+','+z] = type;
  this.rebuildChunk(cx, cz);
  if (lx === 0) this.rebuildChunk(cx - 1, cz);
  if (lx === CHUNK_SIZE - 1) this.rebuildChunk(cx + 1, cz);
  if (lz === 0) this.rebuildChunk(cx, cz - 1);
  if (lz === CHUNK_SIZE - 1) this.rebuildChunk(cx, cz + 1);
};

World.prototype.applyModifications = function(mods) {
  for (var key in mods) {
    var parts = key.split(',');
    var x = parseInt(parts[0]), y = parseInt(parts[1]), z = parseInt(parts[2]);
    var cx = Math.floor(x / CHUNK_SIZE);
    var cz = Math.floor(z / CHUNK_SIZE);
    var lx = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    var lz = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    var chunk = this.getChunk(cx, cz);
    chunk[lx + lz * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE] = mods[key];
  }
  this.modifications = mods;
};

World.prototype.generateChunk = function(cx, cz) {
  var data = new Uint8Array(CHUNK_SIZE * CHUNK_SIZE * CHUNK_HEIGHT);
  var n = this.noise;

  for (var lx = 0; lx < CHUNK_SIZE; lx++) {
    for (var lz = 0; lz < CHUNK_SIZE; lz++) {
      var wx = cx * CHUNK_SIZE + lx;
      var wz = cz * CHUNK_SIZE + lz;
      var h1 = n.octave2D(wx * 0.01, wz * 0.01, 4, 0.5);
      var h2 = n.octave2D(wx * 0.005, wz * 0.005, 2, 0.5);
      var height = Math.floor(SEA_LEVEL + h1 * 12 + h2 * 6);

      for (var y = 0; y < CHUNK_HEIGHT; y++) {
        var idx = lx + lz * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE;
        if (y === 0) {
          data[idx] = B.BEDROCK;
        } else if (y < height - 4) {
          var cave = n.noise3D(wx * 0.05, y * 0.05, wz * 0.05);
          if (cave > 0.4) {
            data[idx] = B.AIR;
          } else {
            data[idx] = B.STONE;
            if (y < 50 && n.noise3D(wx*0.1,y*0.1,wz*0.1) > 0.6) data[idx] = B.COAL;
            if (y < 40 && n.noise3D(wx*0.12+100,y*0.12,wz*0.12) > 0.7) data[idx] = B.IRON;
            if (y < 25 && n.noise3D(wx*0.15+200,y*0.15,wz*0.15) > 0.78) data[idx] = B.GOLD;
            if (y < 15 && n.noise3D(wx*0.18+300,y*0.18,wz*0.18) > 0.84) data[idx] = B.DIAMOND;
          }
        } else if (y < height) {
          data[idx] = B.DIRT;
        } else if (y === height) {
          data[idx] = height <= SEA_LEVEL + 1 ? B.SAND : B.GRASS;
        } else if (y <= SEA_LEVEL) {
          data[idx] = B.WATER;
        } else {
          data[idx] = B.AIR;
        }
      }

      // Arvores
      if (height > SEA_LEVEL + 2) {
        var treeNoise = n.noise2D(wx * 0.3 + 500, wz * 0.3 + 500);
        if (treeNoise > 0.55 && lx > 1 && lx < CHUNK_SIZE - 2 && lz > 1 && lz < CHUNK_SIZE - 2) {
          var treeH = 4 + Math.floor(Math.random() * 3);
          for (var ty = height + 1; ty <= height + treeH && ty < CHUNK_HEIGHT; ty++) {
            data[lx + lz * CHUNK_SIZE + ty * CHUNK_SIZE * CHUNK_SIZE] = B.WOOD;
          }
          var crownBase = height + treeH - 2;
          for (var dy = 0; dy < 4; dy++) {
            var r = dy < 2 ? 2 : 1;
            for (var dx = -r; dx <= r; dx++) {
              for (var dz = -r; dz <= r; dz++) {
                if (dx === 0 && dz === 0 && dy < 3) continue;
                var tx = lx+dx, tz = lz+dz, tty = crownBase+dy;
                if (tx>=0 && tx<CHUNK_SIZE && tz>=0 && tz<CHUNK_SIZE && tty<CHUNK_HEIGHT) {
                  var ci = tx + tz*CHUNK_SIZE + tty*CHUNK_SIZE*CHUNK_SIZE;
                  if (data[ci] === B.AIR) data[ci] = B.LEAVES;
                }
              }
            }
          }
        }
      }
    }
  }
  return data;
};

World.prototype.rebuildChunk = function(cx, cz) {
  var key = this.chunkKey(cx, cz);
  if (this.meshes[key]) {
    this.meshes[key].needsRebuild = true;
  }
};

World.prototype.buildChunkMesh = function(cx, cz, scene, material) {
  var key = this.chunkKey(cx, cz);
  var chunk = this.getChunk(cx, cz);

  if (this.meshes[key]) {
    var old = this.meshes[key];
    if (old.solid) { scene.remove(old.solid); old.solid.geometry.dispose(); }
    if (old.transparent) { scene.remove(old.transparent); old.transparent.geometry.dispose(); }
  }

  var positions = [], normals = [], uvs = [], indices = [];
  var tPositions = [], tNormals = [], tUvs = [], tIndices = [];
  var uStep = 1 / ATLAS_COLS;
  var vStep = 1 / ATLAS_ROWS;

  var faces = [
    { dir:[0,1,0], corners:[[0,1,1],[1,1,1],[1,1,0],[0,1,0]], uvType:'top' },
    { dir:[0,-1,0], corners:[[0,0,0],[1,0,0],[1,0,1],[0,0,1]], uvType:'bottom' },
    { dir:[1,0,0], corners:[[1,0,0],[1,1,0],[1,1,1],[1,0,1]], uvType:'side' },
    { dir:[-1,0,0], corners:[[0,0,1],[0,1,1],[0,1,0],[0,0,0]], uvType:'side' },
    { dir:[0,0,1], corners:[[0,0,1],[1,0,1],[1,1,1],[0,1,1]], uvType:'side' },
    { dir:[0,0,-1], corners:[[1,0,0],[0,0,0],[0,1,0],[1,1,0]], uvType:'side' }
  ];

  for (var lx = 0; lx < CHUNK_SIZE; lx++) {
    for (var lz = 0; lz < CHUNK_SIZE; lz++) {
      for (var y = 0; y < CHUNK_HEIGHT; y++) {
        var block = chunk[lx + lz*CHUNK_SIZE + y*CHUNK_SIZE*CHUNK_SIZE];
        if (block === B.AIR) continue;

        var wx = cx*CHUNK_SIZE + lx;
        var wz = cz*CHUNK_SIZE + lz;
        var blockIsTransparent = isTransparent(block);

        for (var fi = 0; fi < faces.length; fi++) {
          var face = faces[fi];
          var nx = wx + face.dir[0];
          var ny = y + face.dir[1];
          var nz = wz + face.dir[2];
          var neighbor = this.getBlock(nx, ny, nz);

          var shouldDraw;
          if (blockIsTransparent) {
            shouldDraw = (neighbor !== block && isTransparent(neighbor));
          } else {
            shouldDraw = isTransparent(neighbor);
          }
          if (!shouldDraw && neighbor !== B.AIR) continue;
          if (block === B.WATER && face.dir[1] === 0 && neighbor === B.WATER) continue;

          var blockUV = BLOCK_UVS[block];
          if (!blockUV) continue;
          var texCoord = blockUV[face.uvType];

          var p = blockIsTransparent ? tPositions : positions;
          var n = blockIsTransparent ? tNormals : normals;
          var u = blockIsTransparent ? tUvs : uvs;
          var idx2 = blockIsTransparent ? tIndices : indices;
          var vertCount = p.length / 3;

          for (var ci = 0; ci < face.corners.length; ci++) {
            var corner = face.corners[ci];
            p.push(wx+corner[0], y+corner[1], wz+corner[2]);
            n.push(face.dir[0], face.dir[1], face.dir[2]);
          }

          var u0 = texCoord[0] * uStep;
          var v0 = 1 - (texCoord[1]+1) * vStep;
          var u1 = u0 + uStep;
          var v1 = v0 + vStep;
          u.push(u0,v1, u1,v1, u1,v0, u0,v0);

          idx2.push(vertCount, vertCount+1, vertCount+2);
          idx2.push(vertCount, vertCount+2, vertCount+3);
        }
      }
    }
  }

  var entry = { needsRebuild: false, solid: null, transparent: null };

  if (positions.length > 0) {
    var geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geo.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
    geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
    geo.setIndex(indices);
    geo.computeBoundingSphere();
    entry.solid = new THREE.Mesh(geo, material);
    scene.add(entry.solid);
  }

  if (tPositions.length > 0) {
    var geo2 = new THREE.BufferGeometry();
    geo2.setAttribute('position', new THREE.Float32BufferAttribute(tPositions, 3));
    geo2.setAttribute('normal', new THREE.Float32BufferAttribute(tNormals, 3));
    geo2.setAttribute('uv', new THREE.Float32BufferAttribute(tUvs, 2));
    geo2.setIndex(tIndices);
    geo2.computeBoundingSphere();
    var mesh = new THREE.Mesh(geo2, material);
    mesh.renderOrder = 1;
    scene.add(mesh);
    entry.transparent = mesh;
  }

  this.meshes[key] = entry;
};

World.prototype.getHeight = function(x, z) {
  for (var y = CHUNK_HEIGHT - 1; y >= 0; y--) {
    var b = this.getBlock(x, y, z);
    if (b !== B.AIR && b !== B.WATER) return y;
  }
  return 0;
};

// ============================================================
// JOGADOR
// ============================================================
function Player() {
  this.pos = new THREE.Vector3(0, 40, 0);
  this.vel = new THREE.Vector3(0, 0, 0);
  this.yaw = 0;
  this.pitch = 0;
  this.onGround = false;
  this.health = 10;
  this.maxHealth = 10;
  this.hotbar = [B.DIRT, B.GRASS, B.STONE, B.WOOD, B.PLANKS, B.COBBLE, B.SAND, B.GLASS, B.LEAVES];
  this.hotbarCounts = [64,64,64,64,64,64,64,64,64];
  this.selectedSlot = 0;
  this.isDead = false;
  this.damageTimer = 0;
}

Player.prototype.getEyePos = function() {
  return new THREE.Vector3(this.pos.x, this.pos.y + PLAYER_HEIGHT - 0.1, this.pos.z);
};

Player.prototype.getDirection = function() {
  return new THREE.Vector3(
    -Math.sin(this.yaw) * Math.cos(this.pitch),
    Math.sin(this.pitch),
    -Math.cos(this.yaw) * Math.cos(this.pitch)
  ).normalize();
};

Player.prototype.takeDamage = function(amount) {
  if (this.damageTimer > 0) return;
  this.health = Math.max(0, this.health - amount);
  this.damageTimer = 0.5;
  if (this.health <= 0) this.isDead = true;
};

Player.prototype.addItem = function(blockType) {
  var idx = this.hotbar.indexOf(blockType);
  if (idx >= 0) {
    this.hotbarCounts[idx]++;
  } else {
    var empty = this.hotbar.indexOf(0);
    if (empty >= 0) {
      this.hotbar[empty] = blockType;
      this.hotbarCounts[empty] = 1;
    }
  }
};

Player.prototype.update = function(dt, world, moveInput) {
  if (this.isDead) return;
  this.damageTimer = Math.max(0, this.damageTimer - dt);

  var forward = new THREE.Vector3(-Math.sin(this.yaw), 0, -Math.cos(this.yaw));
  var right = new THREE.Vector3(Math.cos(this.yaw), 0, -Math.sin(this.yaw));
  var moveDir = new THREE.Vector3();
  moveDir.addScaledVector(forward, moveInput.z);
  moveDir.addScaledVector(right, moveInput.x);
  if (moveDir.length() > 0) moveDir.normalize();

  this.vel.x = moveDir.x * PLAYER_SPEED;
  this.vel.z = moveDir.z * PLAYER_SPEED;
  this.vel.y += GRAVITY * dt;

  if (moveInput.jump && this.onGround) {
    this.vel.y = JUMP_FORCE;
    this.onGround = false;
  }

  var newPos = this.pos.clone();
  var hw = PLAYER_WIDTH / 2;

  newPos.x += this.vel.x * dt;
  if (this.collidesAt(newPos, world, hw)) { newPos.x = this.pos.x; this.vel.x = 0; }

  newPos.z += this.vel.z * dt;
  if (this.collidesAt(newPos, world, hw)) { newPos.z = this.pos.z; this.vel.z = 0; }

  newPos.y += this.vel.y * dt;
  if (this.collidesAt(newPos, world, hw)) {
    if (this.vel.y < 0) this.onGround = true;
    newPos.y = this.pos.y;
    this.vel.y = 0;
  } else {
    this.onGround = false;
  }

  this.pos.copy(newPos);
  if (this.pos.y < -10) { this.health = 0; this.isDead = true; }
};

Player.prototype.collidesAt = function(pos, world, hw) {
  var minX = Math.floor(pos.x - hw), maxX = Math.floor(pos.x + hw);
  var minY = Math.floor(pos.y), maxY = Math.floor(pos.y + PLAYER_HEIGHT);
  var minZ = Math.floor(pos.z - hw), maxZ = Math.floor(pos.z + hw);
  for (var x = minX; x <= maxX; x++) {
    for (var y = minY; y <= maxY; y++) {
      for (var z = minZ; z <= maxZ; z++) {
        var block = world.getBlock(x, y, z);
        if (block !== B.AIR && block !== B.WATER && !isTransparent(block)) return true;
      }
    }
  }
  return false;
};

// ============================================================
// ZOMBIE
// ============================================================
function Zombie(x, y, z) {
  this.pos = new THREE.Vector3(x, y, z);
  this.vel = new THREE.Vector3(0, 0, 0);
  this.health = 10;
  this.mesh = null;
  this.attackTimer = 0;
  this.onGround = false;
}

Zombie.prototype.createMesh = function() {
  var group = new THREE.Group();
  var bodyGeo = new THREE.BoxGeometry(0.6, 1.0, 0.4);
  var bodyMat = new THREE.MeshLambertMaterial({ color: 0x4a7a3a });
  var body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 1.0;
  group.add(body);

  var headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
  var headMat = new THREE.MeshLambertMaterial({ color: 0x5a8a4a });
  var head = new THREE.Mesh(headGeo, headMat);
  head.position.y = 1.75;
  group.add(head);

  var eyeGeo = new THREE.BoxGeometry(0.1, 0.08, 0.05);
  var eyeMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
  var leftEye = new THREE.Mesh(eyeGeo, eyeMat);
  leftEye.position.set(-0.12, 1.8, -0.26);
  group.add(leftEye);
  var rightEye = new THREE.Mesh(eyeGeo, eyeMat);
  rightEye.position.set(0.12, 1.8, -0.26);
  group.add(rightEye);

  var armGeo = new THREE.BoxGeometry(0.25, 0.7, 0.25);
  var armMat = new THREE.MeshLambertMaterial({ color: 0x4a7a3a });
  var leftArm = new THREE.Mesh(armGeo, armMat);
  leftArm.position.set(-0.45, 1.2, -0.3);
  leftArm.rotation.x = -Math.PI / 3;
  group.add(leftArm);
  var rightArm = new THREE.Mesh(armGeo, armMat);
  rightArm.position.set(0.45, 1.2, -0.3);
  rightArm.rotation.x = -Math.PI / 3;
  group.add(rightArm);

  var legGeo = new THREE.BoxGeometry(0.25, 0.6, 0.25);
  var legMat = new THREE.MeshLambertMaterial({ color: 0x2244aa });
  var leftLeg = new THREE.Mesh(legGeo, legMat);
  leftLeg.position.set(-0.18, 0.3, 0);
  group.add(leftLeg);
  var rightLeg = new THREE.Mesh(legGeo, legMat);
  rightLeg.position.set(0.18, 0.3, 0);
  group.add(rightLeg);

  this.mesh = group;
  return group;
};

Zombie.prototype.update = function(dt, world, playerPos) {
  this.attackTimer = Math.max(0, this.attackTimer - dt);
  var dx = playerPos.x - this.pos.x;
  var dz = playerPos.z - this.pos.z;
  var dist = Math.sqrt(dx * dx + dz * dz);

  if (dist > 0.5 && dist < 40) {
    this.vel.x = (dx / dist) * ZOMBIE_SPEED;
    this.vel.z = (dz / dist) * ZOMBIE_SPEED;
    if (this.mesh) this.mesh.rotation.y = Math.atan2(dx, dz);
  } else {
    this.vel.x = 0;
    this.vel.z = 0;
  }

  this.vel.y += GRAVITY * dt;
  var newX = this.pos.x + this.vel.x * dt;
  var newZ = this.pos.z + this.vel.z * dt;
  var newY = this.pos.y + this.vel.y * dt;

  var bx = Math.floor(newX), by = Math.floor(this.pos.y + 0.5), bz = Math.floor(this.pos.z);
  var blockAtX = world.getBlock(bx, by, bz);
  if (blockAtX !== B.AIR && !isTransparent(blockAtX)) {
    if (world.getBlock(bx, by+1, bz) === B.AIR && this.onGround) {
      this.vel.y = JUMP_FORCE * 0.7;
      this.onGround = false;
    }
  } else {
    this.pos.x = newX;
  }

  var bz2 = Math.floor(newZ);
  var blockAtZ = world.getBlock(Math.floor(this.pos.x), by, bz2);
  if (blockAtZ !== B.AIR && !isTransparent(blockAtZ)) {
    if (world.getBlock(Math.floor(this.pos.x), by+1, bz2) === B.AIR && this.onGround) {
      this.vel.y = JUMP_FORCE * 0.7;
      this.onGround = false;
    }
  } else {
    this.pos.z = newZ;
  }

  var by2 = Math.floor(newY);
  var blockAtY = by2 >= 0 ? world.getBlock(Math.floor(this.pos.x), by2, Math.floor(this.pos.z)) : B.AIR;
  if (blockAtY !== B.AIR && !isTransparent(blockAtY)) {
    if (this.vel.y < 0) this.onGround = true;
    this.vel.y = 0;
  } else {
    this.pos.y = newY;
    this.onGround = false;
  }

  if (this.mesh && dist < 40) {
    var walkAnim = Math.sin(Date.now() * 0.008) * 0.5;
    if (this.mesh.children[6]) this.mesh.children[6].rotation.x = walkAnim;
    if (this.mesh.children[7]) this.mesh.children[7].rotation.x = -walkAnim;
  }
  if (this.mesh) this.mesh.position.copy(this.pos);
};

Zombie.prototype.canAttack = function(playerPos) {
  return this.pos.distanceTo(playerPos) < ZOMBIE_RANGE && this.attackTimer <= 0;
};

Zombie.prototype.attack = function() { this.attackTimer = 1.0; };

Zombie.prototype.takeDamage = function(amount) {
  this.health -= amount;
  return this.health <= 0;
};

// ============================================================
// RAYCASTING
// ============================================================
function raycast(world, origin, direction, maxDist) {
  var dx = direction.x, dy = direction.y, dz = direction.z;
  var x = Math.floor(origin.x), y = Math.floor(origin.y), z = Math.floor(origin.z);
  var stepX = dx > 0 ? 1 : -1;
  var stepY = dy > 0 ? 1 : -1;
  var stepZ = dz > 0 ? 1 : -1;
  var tMaxX = dx !== 0 ? ((dx > 0 ? x+1 : x) - origin.x) / dx : Infinity;
  var tMaxY = dy !== 0 ? ((dy > 0 ? y+1 : y) - origin.y) / dy : Infinity;
  var tMaxZ = dz !== 0 ? ((dz > 0 ? z+1 : z) - origin.z) / dz : Infinity;
  var tDeltaX = dx !== 0 ? Math.abs(1/dx) : Infinity;
  var tDeltaY = dy !== 0 ? Math.abs(1/dy) : Infinity;
  var tDeltaZ = dz !== 0 ? Math.abs(1/dz) : Infinity;
  var prevX = x, prevY = y, prevZ = z;

  for (var i = 0; i < maxDist * 3; i++) {
    var block = world.getBlock(x, y, z);
    if (block !== B.AIR && block !== B.WATER) {
      return { x:x, y:y, z:z, block:block, prevX:prevX, prevY:prevY, prevZ:prevZ };
    }
    prevX = x; prevY = y; prevZ = z;
    if (tMaxX < tMaxY) {
      if (tMaxX < tMaxZ) { x += stepX; tMaxX += tDeltaX; }
      else { z += stepZ; tMaxZ += tDeltaZ; }
    } else {
      if (tMaxY < tMaxZ) { y += stepY; tMaxY += tDeltaY; }
      else { z += stepZ; tMaxZ += tDeltaZ; }
    }
    var d = Math.sqrt((x-origin.x)*(x-origin.x)+(y-origin.y)*(y-origin.y)+(z-origin.z)*(z-origin.z));
    if (d > maxDist) break;
  }
  return null;
}

// ============================================================
// JOGO
// ============================================================
var game = null;

function Game() {
  this.scene = new THREE.Scene();
  this.camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 300);
  this.renderer = new THREE.WebGLRenderer({ antialias: false });
  this.renderer.setSize(window.innerWidth, window.innerHeight);
  this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  this.renderer.setClearColor(0x87CEEB);
  document.body.appendChild(this.renderer.domElement);

  var atlasCanvas = createTextureAtlas();
  this.atlasTexture = new THREE.CanvasTexture(atlasCanvas);
  this.atlasTexture.magFilter = THREE.NearestFilter;
  this.atlasTexture.minFilter = THREE.NearestFilter;
  this.atlasTexture.colorSpace = THREE.SRGBColorSpace;

  this.blockMaterial = new THREE.MeshLambertMaterial({
    map: this.atlasTexture, side: THREE.FrontSide, alphaTest: 0.1
  });

  this.world = new World(Math.floor(Math.random() * 100000));
  this.player = new Player();
  this.zombies = [];
  this.timeOfDay = 0.25;
  this.dayCount = 0;

  this.ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  this.scene.add(this.ambientLight);
  this.sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
  this.sunLight.position.set(50, 100, 50);
  this.scene.add(this.sunLight);
  this.scene.fog = new THREE.Fog(0x87CEEB, 40, 80);

  var hlGeo = new THREE.BoxGeometry(1.002, 1.002, 1.002);
  var hlMat = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true, opacity: 0.4 });
  this.blockHighlight = new THREE.Mesh(hlGeo, hlMat);
  this.blockHighlight.visible = false;
  this.scene.add(this.blockHighlight);

  this.keys = {};
  this.mouseDown = { left: false, right: false };
  this.touchMoveVec = { x: 0, z: 0 };
  this.touchJump = false;
  this.touchBreak = false;
  this.touchPlace = false;
  this.isTouch = false;
  this.pointerLocked = false;
  this.breakProgress = 0;
  this.breakTarget = null;
  this.loadedChunks = {};
  this.lastTime = performance.now();

  this.saveTimer = 0;
  this.setupInput();
  this.setupHUD();
  this.spawnPlayer();
}

Game.prototype.save = function() {
  var data = {
    seed: this.world.seed,
    playerX: this.player.pos.x,
    playerY: this.player.pos.y,
    playerZ: this.player.pos.z,
    playerYaw: this.player.yaw,
    playerPitch: this.player.pitch,
    playerHealth: this.player.health,
    hotbar: this.player.hotbar,
    hotbarCounts: this.player.hotbarCounts,
    selectedSlot: this.player.selectedSlot,
    timeOfDay: this.timeOfDay,
    dayCount: this.dayCount,
    modifications: this.world.modifications
  };
  try {
    localStorage.setItem('martincraft_save', JSON.stringify(data));
    var msg = document.getElementById('save-msg');
    msg.textContent = 'Jogo guardado!';
    msg.style.opacity = '1';
    setTimeout(function() { msg.style.opacity = '0'; }, 2000);
  } catch(e) { /* localStorage full or unavailable */ }
};

Game.prototype.loadSave = function(data) {
  this.world = new World(data.seed);
  if (data.modifications) {
    this.world.applyModifications(data.modifications);
  }
  this.player.pos.set(data.playerX, data.playerY, data.playerZ);
  this.player.yaw = data.playerYaw || 0;
  this.player.pitch = data.playerPitch || 0;
  this.player.health = data.playerHealth || 10;
  this.player.hotbar = data.hotbar || this.player.hotbar;
  this.player.hotbarCounts = data.hotbarCounts || this.player.hotbarCounts;
  this.player.selectedSlot = data.selectedSlot || 0;
  this.timeOfDay = data.timeOfDay || 0.25;
  this.dayCount = data.dayCount || 0;
  this.updateHotbar();
  this.updateHearts();
};

Game.prototype.spawnPlayer = function() {
  var h = this.world.getHeight(0, 0);
  this.player.pos.set(0.5, h + 2, 0.5);
};

Game.prototype.setupInput = function() {
  var self = this;

  window.addEventListener('keydown', function(e) {
    self.keys[e.code] = true;
    if (e.code >= 'Digit1' && e.code <= 'Digit9') {
      self.player.selectedSlot = parseInt(e.code.replace('Digit', '')) - 1;
      self.updateHotbar();
    }
    if (e.code === 'KeyP') { self.save(); }
  });

  document.getElementById('save-btn').addEventListener('click', function() {
    self.save();
  });
  window.addEventListener('keyup', function(e) { self.keys[e.code] = false; });

  this.renderer.domElement.addEventListener('click', function() {
    if (!self.isTouch && !self.pointerLocked) {
      self.renderer.domElement.requestPointerLock();
    }
  });

  document.addEventListener('pointerlockchange', function() {
    self.pointerLocked = document.pointerLockElement === self.renderer.domElement;
  });

  document.addEventListener('mousemove', function(e) {
    if (self.pointerLocked) {
      self.player.yaw -= e.movementX * 0.002;
      self.player.pitch = Math.max(-Math.PI/2.1, Math.min(Math.PI/2.1, self.player.pitch + e.movementY * -0.002));
    }
  });

  document.addEventListener('mousedown', function(e) {
    if (!self.pointerLocked) return;
    if (e.button === 0) self.mouseDown.left = true;
    if (e.button === 2) self.mouseDown.right = true;
  });

  document.addEventListener('mouseup', function(e) {
    if (e.button === 0) self.mouseDown.left = false;
    if (e.button === 2) self.mouseDown.right = false;
  });

  document.addEventListener('contextmenu', function(e) { e.preventDefault(); });

  document.addEventListener('wheel', function(e) {
    if (e.deltaY > 0) self.player.selectedSlot = (self.player.selectedSlot + 1) % 9;
    else self.player.selectedSlot = (self.player.selectedSlot + 8) % 9;
    self.updateHotbar();
  });

  this.setupTouchControls();

  window.addEventListener('resize', function() {
    self.camera.aspect = window.innerWidth / window.innerHeight;
    self.camera.updateProjectionMatrix();
    self.renderer.setSize(window.innerWidth, window.innerHeight);
  });
};

Game.prototype.setupTouchControls = function() {
  var self = this;
  var thumb = document.getElementById('joystick-thumb');
  var base = document.getElementById('joystick-base');
  var joystickArea = document.getElementById('joystick-area');
  var joystickActive = false;
  var joystickId = null;
  var lookId = null;
  var lastLookX = 0, lastLookY = 0;

  var isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  if (isTouchDevice) {
    self.isTouch = true;
    document.getElementById('touch-controls').style.display = 'block';
    document.getElementById('crosshair').style.display = 'none';
  }

  joystickArea.addEventListener('touchstart', function(e) {
    e.preventDefault();
    joystickActive = true;
    joystickId = e.changedTouches[0].identifier;
  }, { passive: false });

  document.addEventListener('touchmove', function(e) {
    for (var i = 0; i < e.changedTouches.length; i++) {
      var touch = e.changedTouches[i];
      if (touch.identifier === joystickId && joystickActive) {
        var rect = base.getBoundingClientRect();
        var cx = rect.left + rect.width/2;
        var cy = rect.top + rect.height/2;
        var dx = touch.clientX - cx;
        var dy = touch.clientY - cy;
        var dist = Math.sqrt(dx*dx + dy*dy);
        var maxDist = 50;
        if (dist > maxDist) { dx = dx/dist*maxDist; dy = dy/dist*maxDist; }
        thumb.style.left = (35+dx)+'px';
        thumb.style.top = (35+dy)+'px';
        self.touchMoveVec.x = dx/maxDist;
        self.touchMoveVec.z = dy/maxDist;
      }
      if (touch.identifier === lookId) {
        var dlx = touch.clientX - lastLookX;
        var dly = touch.clientY - lastLookY;
        self.player.yaw -= dlx * 0.004;
        self.player.pitch = Math.max(-Math.PI/2.1, Math.min(Math.PI/2.1, self.player.pitch - dly*0.004));
        lastLookX = touch.clientX;
        lastLookY = touch.clientY;
      }
    }
  }, { passive: false });

  document.addEventListener('touchend', function(e) {
    for (var i = 0; i < e.changedTouches.length; i++) {
      var touch = e.changedTouches[i];
      if (touch.identifier === joystickId) {
        joystickActive = false;
        joystickId = null;
        thumb.style.left = '35px';
        thumb.style.top = '35px';
        self.touchMoveVec.x = 0;
        self.touchMoveVec.z = 0;
      }
      if (touch.identifier === lookId) { lookId = null; }
    }
  });

  self.renderer.domElement.addEventListener('touchstart', function(e) {
    for (var i = 0; i < e.changedTouches.length; i++) {
      var touch = e.changedTouches[i];
      if (touch.clientX > window.innerWidth * 0.3 && lookId === null) {
        lookId = touch.identifier;
        lastLookX = touch.clientX;
        lastLookY = touch.clientY;
      }
    }
  }, { passive: true });

  document.getElementById('jump-btn').addEventListener('touchstart', function(e) {
    e.preventDefault(); self.touchJump = true;
  }, { passive: false });
  document.getElementById('jump-btn').addEventListener('touchend', function() { self.touchJump = false; });

  document.getElementById('break-btn').addEventListener('touchstart', function(e) {
    e.preventDefault(); self.touchBreak = true;
  }, { passive: false });
  document.getElementById('break-btn').addEventListener('touchend', function() { self.touchBreak = false; });

  document.getElementById('place-btn').addEventListener('touchstart', function(e) {
    e.preventDefault(); self.touchPlace = true;
  }, { passive: false });
  document.getElementById('place-btn').addEventListener('touchend', function() { self.touchPlace = false; });

  document.getElementById('hotbar').addEventListener('touchstart', function(e) {
    var slots = document.querySelectorAll('.hotbar-slot');
    var touch = e.changedTouches[0];
    for (var i = 0; i < slots.length; i++) {
      var rect = slots[i].getBoundingClientRect();
      if (touch.clientX >= rect.left && touch.clientX <= rect.right &&
          touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
        self.player.selectedSlot = i;
        self.updateHotbar();
        break;
      }
    }
  }, { passive: true });
};

Game.prototype.setupHUD = function() {
  var heartsDiv = document.getElementById('hearts');
  while (heartsDiv.firstChild) heartsDiv.removeChild(heartsDiv.firstChild);
  for (var i = 0; i < 10; i++) {
    var heart = document.createElement('div');
    heart.className = 'heart';
    heart.id = 'heart-' + i;
    heartsDiv.appendChild(heart);
  }
  this.updateHearts();
  this.updateHotbar();
};

Game.prototype.updateHearts = function() {
  for (var i = 0; i < 10; i++) {
    var heart = document.getElementById('heart-' + i);
    if (heart) {
      var full = i < this.player.health;
      heart.textContent = full ? '\u2764' : '\u{1F5A4}';
      heart.style.fontSize = '22px';
      heart.style.lineHeight = '28px';
      heart.style.textAlign = 'center';
    }
  }
};

Game.prototype.updateHotbar = function() {
  var hotbar = document.getElementById('hotbar');
  while (hotbar.firstChild) hotbar.removeChild(hotbar.firstChild);
  for (var i = 0; i < 9; i++) {
    var slot = document.createElement('div');
    slot.className = 'hotbar-slot' + (i === this.player.selectedSlot ? ' selected' : '');
    if (this.player.hotbar[i]) {
      var preview = this.createBlockPreview(this.player.hotbar[i]);
      slot.appendChild(preview);
      var count = document.createElement('span');
      count.className = 'hotbar-count';
      count.textContent = String(this.player.hotbarCounts[i]);
      slot.appendChild(count);
    }
    hotbar.appendChild(slot);
  }
};

Game.prototype.createBlockPreview = function(blockType) {
  var canvas = document.createElement('canvas');
  canvas.width = 32;
  canvas.height = 32;
  var ctx = canvas.getContext('2d');
  var uvData = BLOCK_UVS[blockType];
  if (!uvData) return canvas;
  var atlasCanvas = this.atlasTexture.image;
  if (atlasCanvas) {
    var sideCoord = uvData.side;
    var topCoord = uvData.top;
    ctx.drawImage(atlasCanvas, sideCoord[0]*TEX_SIZE, sideCoord[1]*TEX_SIZE, TEX_SIZE, TEX_SIZE, 0, 8, 24, 24);
    ctx.drawImage(atlasCanvas, topCoord[0]*TEX_SIZE, topCoord[1]*TEX_SIZE, TEX_SIZE, TEX_SIZE, 4, 0, 24, 16);
  }
  return canvas;
};

Game.prototype.updateChunks = function() {
  var pcx = Math.floor(this.player.pos.x / CHUNK_SIZE);
  var pcz = Math.floor(this.player.pos.z / CHUNK_SIZE);
  var newLoaded = {};
  var built = 0;

  for (var dx = -RENDER_DIST; dx <= RENDER_DIST; dx++) {
    for (var dz = -RENDER_DIST; dz <= RENDER_DIST; dz++) {
      if (dx*dx + dz*dz > RENDER_DIST*RENDER_DIST) continue;
      var cx = pcx+dx, cz = pcz+dz;
      var key = this.world.chunkKey(cx, cz);
      newLoaded[key] = true;
      var existing = this.world.meshes[key];
      if (!existing || existing.needsRebuild) {
        if (built < 2) {
          this.world.buildChunkMesh(cx, cz, this.scene, this.blockMaterial);
          built++;
        }
      }
    }
  }

  for (var key2 in this.loadedChunks) {
    if (!newLoaded[key2]) {
      var entry = this.world.meshes[key2];
      if (entry) {
        if (entry.solid) { this.scene.remove(entry.solid); entry.solid.geometry.dispose(); }
        if (entry.transparent) { this.scene.remove(entry.transparent); entry.transparent.geometry.dispose(); }
        delete this.world.meshes[key2];
      }
    }
  }
  this.loadedChunks = newLoaded;
};

Game.prototype.updateDayNight = function(dt) {
  this.timeOfDay += dt / DAY_LENGTH;
  if (this.timeOfDay >= 1) { this.timeOfDay -= 1; this.dayCount++; }

  var sunAngle = this.timeOfDay * Math.PI * 2 - Math.PI / 2;
  this.sunLight.position.set(Math.cos(sunAngle)*100, Math.sin(sunAngle)*100, 50);

  var isNight = this.timeOfDay > 0.75 || this.timeOfDay < 0.2;
  var isDusk = this.timeOfDay > 0.7 && this.timeOfDay <= 0.75;
  var isDawn = this.timeOfDay >= 0.2 && this.timeOfDay < 0.25;

  var sunIntensity, ambIntensity, skyColor;

  if (isNight) {
    sunIntensity = 0.1; ambIntensity = 0.15;
    skyColor = new THREE.Color(0x0a0a2e);
  } else if (isDusk) {
    var t = (this.timeOfDay - 0.7) / 0.05;
    sunIntensity = 0.8 - t*0.7; ambIntensity = 0.5 - t*0.35;
    skyColor = new THREE.Color(0x87CEEB).lerp(new THREE.Color(0xff6633), t);
  } else if (isDawn) {
    var t2 = (this.timeOfDay - 0.2) / 0.05;
    sunIntensity = 0.1 + t2*0.7; ambIntensity = 0.15 + t2*0.35;
    skyColor = new THREE.Color(0x0a0a2e).lerp(new THREE.Color(0xff9966), t2);
  } else {
    sunIntensity = 0.8; ambIntensity = 0.5;
    skyColor = new THREE.Color(0x87CEEB);
  }

  this.sunLight.intensity = sunIntensity;
  this.ambientLight.intensity = ambIntensity;
  this.renderer.setClearColor(skyColor);
  this.scene.fog.color = skyColor;
};

Game.prototype.isNight = function() {
  return this.timeOfDay > 0.75 || this.timeOfDay < 0.2;
};

Game.prototype.updateZombies = function(dt) {
  var self = this;
  if (this.isNight() && this.zombies.length < MAX_ZOMBIES) {
    if (Math.random() < 0.01) {
      var angle = Math.random() * Math.PI * 2;
      var dist = ZOMBIE_SPAWN_DIST_MIN + Math.random()*(ZOMBIE_SPAWN_DIST_MAX - ZOMBIE_SPAWN_DIST_MIN);
      var sx = this.player.pos.x + Math.cos(angle)*dist;
      var sz = this.player.pos.z + Math.sin(angle)*dist;
      var sy = this.world.getHeight(Math.floor(sx), Math.floor(sz)) + 1;
      var zombie = new Zombie(sx, sy, sz);
      var mesh = zombie.createMesh();
      this.scene.add(mesh);
      this.zombies.push(zombie);
    }
  }

  if (!this.isNight()) {
    for (var i = this.zombies.length - 1; i >= 0; i--) {
      this.zombies[i].health -= dt * 3;
      if (this.zombies[i].health <= 0) {
        if (this.zombies[i].mesh) this.scene.remove(this.zombies[i].mesh);
        this.zombies.splice(i, 1);
      }
    }
  }

  for (var j = this.zombies.length - 1; j >= 0; j--) {
    var z = this.zombies[j];
    z.update(dt, this.world, this.player.pos);
    if (z.canAttack(this.player.pos)) {
      this.player.takeDamage(ZOMBIE_DAMAGE);
      z.attack();
    }
    if (z.health <= 0) {
      if (z.mesh) this.scene.remove(z.mesh);
      this.zombies.splice(j, 1);
      continue;
    }
    if (z.pos.distanceTo(this.player.pos) > 60) {
      if (z.mesh) this.scene.remove(z.mesh);
      this.zombies.splice(j, 1);
    }
  }
};

Game.prototype.handleBlockInteraction = function(dt) {
  var origin = this.player.getEyePos();
  var dir = this.player.getDirection();
  var hit = raycast(this.world, origin, dir, 6);

  if (hit) {
    this.blockHighlight.position.set(hit.x+0.5, hit.y+0.5, hit.z+0.5);
    this.blockHighlight.visible = true;
  } else {
    this.blockHighlight.visible = false;
  }

  var isBreaking = this.mouseDown.left || this.touchBreak;
  if (isBreaking && hit) {
    var target = hit.x+','+hit.y+','+hit.z;
    if (target !== this.breakTarget) { this.breakProgress = 0; this.breakTarget = target; }
    var hardness = BLOCK_HARDNESS[hit.block] || 1;
    this.breakProgress += dt / (hardness * BLOCK_BREAK_TIME);
    if (this.breakProgress >= 1) {
      this.player.addItem(hit.block);
      this.world.setBlock(hit.x, hit.y, hit.z, B.AIR);
      this.breakProgress = 0;
      this.breakTarget = null;
      this.updateHotbar();
    }
  } else {
    this.breakProgress = 0;
    this.breakTarget = null;
  }

  var isPlacing = this.mouseDown.right || this.touchPlace;
  if (isPlacing && hit) {
    var slot = this.player.hotbar[this.player.selectedSlot];
    if (slot && this.player.hotbarCounts[this.player.selectedSlot] > 0) {
      var px = Math.floor(this.player.pos.x);
      var py = Math.floor(this.player.pos.y);
      var pz = Math.floor(this.player.pos.z);
      if (!(hit.prevX===px && (hit.prevY===py||hit.prevY===py+1) && hit.prevZ===pz)) {
        if (this.world.getBlock(hit.prevX, hit.prevY, hit.prevZ) === B.AIR) {
          this.world.setBlock(hit.prevX, hit.prevY, hit.prevZ, slot);
          this.player.hotbarCounts[this.player.selectedSlot]--;
          if (this.player.hotbarCounts[this.player.selectedSlot] <= 0) {
            this.player.hotbar[this.player.selectedSlot] = 0;
          }
          this.updateHotbar();
          this.mouseDown.right = false;
          this.touchPlace = false;
        }
      }
    }
  }

  if ((this.mouseDown.left || this.touchBreak) && !hit) {
    for (var i = 0; i < this.zombies.length; i++) {
      var zombie = this.zombies[i];
      var toZombie = zombie.pos.clone().sub(origin);
      var zDist = toZombie.length();
      if (zDist < 4) {
        toZombie.normalize();
        if (dir.dot(toZombie) > 0.8) {
          zombie.takeDamage(3);
          zombie.vel.x = dir.x * 5;
          zombie.vel.z = dir.z * 5;
          zombie.vel.y = 3;
          break;
        }
      }
    }
  }
};

Game.prototype.getMovementInput = function() {
  var input = { x: 0, z: 0, jump: false };
  if (this.keys['KeyW'] || this.keys['ArrowUp']) input.z = 1;
  if (this.keys['KeyS'] || this.keys['ArrowDown']) input.z = -1;
  if (this.keys['KeyA'] || this.keys['ArrowLeft']) input.x = -1;
  if (this.keys['KeyD'] || this.keys['ArrowRight']) input.x = 1;
  if (this.keys['Space']) input.jump = true;
  if (this.isTouch) {
    input.x = this.touchMoveVec.x;
    input.z = -this.touchMoveVec.z;
    if (this.touchJump) input.jump = true;
  }
  return input;
};

Game.prototype.loop = function() {
  var self = this;
  var now = performance.now();
  var dt = (now - this.lastTime) / 1000;
  this.lastTime = now;
  dt = Math.min(dt, 0.1);

  if (this.player.isDead) {
    document.getElementById('death-screen').style.display = 'flex';
    requestAnimationFrame(function() { self.loop(); });
    return;
  }

  var moveInput = this.getMovementInput();
  this.player.update(dt, this.world, moveInput);
  this.updateDayNight(dt);
  this.updateZombies(dt);
  this.handleBlockInteraction(dt);
  this.updateChunks();
  this.updateHearts();

  var eye = this.player.getEyePos();
  this.camera.position.copy(eye);
  this.camera.rotation.order = 'YXZ';
  this.camera.rotation.y = this.player.yaw;
  this.camera.rotation.x = this.player.pitch;

  var info = document.getElementById('debug-info');
  var timeStr = this.isNight() ? 'Noite' : 'Dia';
  info.textContent = timeStr + ' | Dia ' + (this.dayCount + 1) +
    '\nPos: ' + Math.floor(this.player.pos.x) + ', ' +
    Math.floor(this.player.pos.y) + ', ' + Math.floor(this.player.pos.z) +
    '\nZombies: ' + this.zombies.length;

  if (this.player.damageTimer > 0.3) {
    this.renderer.domElement.style.filter = 'brightness(1.5) saturate(2)';
  } else {
    this.renderer.domElement.style.filter = '';
  }

  // Auto-save every 30 seconds
  this.saveTimer += dt;
  if (this.saveTimer >= 30) {
    this.saveTimer = 0;
    this.save();
  }

  this.renderer.render(this.scene, this.camera);
  requestAnimationFrame(function() { self.loop(); });
};

// ============================================================
// INICIAR / RENASCER
// ============================================================

// Show continue button if save exists
var hasSave = false;
try { hasSave = !!localStorage.getItem('martincraft_save'); } catch(e) {}
if (hasSave) {
  document.getElementById('continue-btn').style.display = '';
}

function launchGame(saveData) {
  document.getElementById('menu').style.display = 'none';
  document.getElementById('loading').style.display = 'flex';

  var progress = 0;
  var loadInterval = setInterval(function() {
    progress += 5;
    document.getElementById('loading-fill').style.width = progress + '%';
    if (progress >= 100) {
      clearInterval(loadInterval);
      document.getElementById('loading').style.display = 'none';
      document.getElementById('hud').style.display = 'block';

      game = new Game();

      if (saveData) {
        game.loadSave(saveData);
      }

      var pcx = Math.floor(game.player.pos.x / CHUNK_SIZE);
      var pcz = Math.floor(game.player.pos.z / CHUNK_SIZE);
      for (var dx = -2; dx <= 2; dx++) {
        for (var dz = -2; dz <= 2; dz++) {
          game.world.buildChunkMesh(pcx+dx, pcz+dz, game.scene, game.blockMaterial);
          game.loadedChunks[game.world.chunkKey(pcx+dx, pcz+dz)] = true;
        }
      }

      game.loop();
    }
  }, 50);
}

document.getElementById('play-btn').addEventListener('click', function() {
  launchGame(null);
});

document.getElementById('continue-btn').addEventListener('click', function() {
  var saveData = null;
  try {
    var raw = localStorage.getItem('martincraft_save');
    if (raw) saveData = JSON.parse(raw);
  } catch(e) {}
  launchGame(saveData);
});

document.getElementById('respawn-btn').addEventListener('click', function() {
  if (!game) return;
  document.getElementById('death-screen').style.display = 'none';
  game.player.health = game.player.maxHealth;
  game.player.isDead = false;
  game.player.vel.set(0, 0, 0);
  game.spawnPlayer();
});
</script>
</body>
</html>
